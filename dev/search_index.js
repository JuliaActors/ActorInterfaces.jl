var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference-1","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"reference/#","page":"Reference","title":"Reference","text":"Modules = [ActorInterfaces]","category":"page"},{"location":"reference/#ActorInterfaces.MissingActorSystem","page":"Reference","title":"ActorInterfaces.MissingActorSystem","text":"MissingActorSystem <: ActorException\n\nNo ActorInterface implementation is loaded.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ActorInterfaces._actorsystem","page":"Reference","title":"ActorInterfaces._actorsystem","text":"_actorsystem\n\n\n\n\n\n","category":"function"},{"location":"reference/#ActorInterfaces.actorsystem-Tuple{}","page":"Reference","title":"ActorInterfaces.actorsystem","text":"actorsystem()::Module\n\nReturn the currently active implementation of ActorInterfaces, or throw MissingActorSystem.\n\n\n\n\n\n","category":"method"},{"location":"reference/#","page":"Reference","title":"Reference","text":"Modules = [ActorInterfaces.Classic]","category":"page"},{"location":"reference/#ActorInterfaces.Classic","page":"Reference","title":"ActorInterfaces.Classic","text":"module ActorInterfaces.Classic\n\nThe Classic model is the one described by Gul Agha in the book \"ACTORS: A Model of Concurrent Computation in Distributed Systems\"\n\n\n\n\n\n","category":"module"},{"location":"reference/#ActorInterfaces.Classic.Addr","page":"Reference","title":"ActorInterfaces.Classic.Addr","text":"Addr\n\nAddr uniquely identifies an actor, and can be used as the target of messages.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ActorInterfaces.Classic.become","page":"Reference","title":"ActorInterfaces.Classic.become","text":"become(behavior, [ctx])\n\nReplace the behavior of the current actor with behavior. \n\nThe new behavior will be effective at the processing of the next message.\n\nThe ctx argument can be automatically injected by @ctx.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ActorInterfaces.Classic.self","page":"Reference","title":"ActorInterfaces.Classic.self","text":"self([ctx]) :: Addr\n\nGet the address of the current actor.\n\nThe ctx argument can be automatically injected by @ctx.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ActorInterfaces.Classic.send","page":"Reference","title":"ActorInterfaces.Classic.send","text":"send(recipient::Addr, msg, [ctx])\n\nSend the message msg to a recipient actor address.\n\nThe ctx argument can be automatically injected by @ctx.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ActorInterfaces.Classic.spawn","page":"Reference","title":"ActorInterfaces.Classic.spawn","text":"spawn(behavior, [ctx]) :: Addr\n\nCreate a new actor from the given behavior and schedule it.\n\nThe returned address can be used to send messages to the newly created actor. The actor itself is not accessible directly.\n\nThe ctx argument can be automatically injected by @ctx.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ActorInterfaces.Classic.@ctx-Tuple{Any}","page":"Reference","title":"ActorInterfaces.Classic.@ctx","text":"@ctx\n\nInject the actor context into onmessage methods automatically.\n\nThe \"actor context\" allows the runtime to identify the current actor efficiently. It is passed to onmessage and must be provided to every actor primitive call. It can either be handled explicitly by the user or implicitly by the @ctx macro.\n\nWhen an onmessage method definition is marked with @ctx, calls to send, spawn, etc. from it need not to handle the ctx argument, it will be injected by the macro.\n\n\n\n\n\n","category":"macro"},{"location":"reference/#ActorInterfaces.Classic.onmessage","page":"Reference","title":"ActorInterfaces.Classic.onmessage","text":"Classic.onmessage(me, msg, ctx)\n@ctx Classic.onmessage(me, msg)\n\nHandle the incoming message msg received by an actor with behavior me.\n\nMessages will be dispatched to methods of this function.\n\nNote on async and blocking: @async is allowed in onmessage, but async code should not operate directly on the actor state, only through messages. Blocking operations will also work inside onmessage, but in the Classic model it is up to the implementation to provide any or no concurrency of blocked actors, so blocking should generally be avoided if possible.\n\nExamples\n\nmutable struct Counter\n    counter::Int\nend\n\nstruct Increment end\n\n@ctx function Classic.onmessage(me::Counter, msg::Increment)\n    me.counter += 1\nend\n\n\n\n\n\n","category":"function"},{"location":"#ActorInterfaces.jl-1","page":"ActorInterfaces.jl","title":"ActorInterfaces.jl","text":"","category":"section"},{"location":"#","page":"ActorInterfaces.jl","title":"ActorInterfaces.jl","text":"ActorInterfaces.jl is a formalisation of the actor model family in Julia. Its main goal is to allow writing actor programs independently from any specific implementation of the model. Programs written on top of ActorInterfaces.jl will potentially run on several actor systems.","category":"page"},{"location":"#","page":"ActorInterfaces.jl","title":"ActorInterfaces.jl","text":"There is no such thing as The Actor Model, there are interpretations and extensions of it. ActorInterfaces tries to handle this diversity by defining a minimalistic base called the Classic Model, and extensions to it. ","category":"page"},{"location":"#","page":"ActorInterfaces.jl","title":"ActorInterfaces.jl","text":"Current State: The Classic interface settled recently, major semantical changes are unlikely. Extensions will be added continously. If you have an extension idea, please open an issue or a topic on Discourse.","category":"page"},{"location":"#","page":"ActorInterfaces.jl","title":"ActorInterfaces.jl","text":"Known implementations:","category":"page"},{"location":"#","page":"ActorInterfaces.jl","title":"ActorInterfaces.jl","text":"QuickActors.jl, reference implementation.","category":"page"}]
}
