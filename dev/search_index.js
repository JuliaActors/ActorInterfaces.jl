var documenterSearchIndex = {"docs":
[{"location":"reference/#Reference-1","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"","category":"page"},{"location":"reference/#","page":"Reference","title":"Reference","text":"Modules = [ActorInterfaces]","category":"page"},{"location":"reference/#ActorInterfaces.MissingActorSystem","page":"Reference","title":"ActorInterfaces.MissingActorSystem","text":"MissingActorSystem <: ActorException\n\nNo ActorInterface implementation is loaded.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ActorInterfaces._actorsystem","page":"Reference","title":"ActorInterfaces._actorsystem","text":"_actorsystem\n\n\n\n\n\n","category":"function"},{"location":"reference/#ActorInterfaces.actorsystem-Tuple{}","page":"Reference","title":"ActorInterfaces.actorsystem","text":"actorsystem()::Module\n\nReturn the currently active implementation of ActorInterfaces, or throw MissingActorSystem.\n\n\n\n\n\n","category":"method"},{"location":"reference/#","page":"Reference","title":"Reference","text":"Modules = [ActorInterfaces.Classic]","category":"page"},{"location":"reference/#ActorInterfaces.Classic","page":"Reference","title":"ActorInterfaces.Classic","text":"module ActorInterfaces.Classic\n\nThe Classic model is the one described by Gul Agha in the book \"ACTORS: A Model of Concurrent Computation in Distributed Systems\"\n\nAn actor is spawned from a behavior (a function or other callable object), incoming messages will be dispatched to it. While handling the message, the behavior can use the primitives send, spawn, become and self.\n\nA so-called context will also be provided by the runtime to the behavior, in the keyword argument ctx. It must be forwarded to the primitives, helping the runtime to manage actors without having global state. The macro @ctx does this forwarding automatically.\n\nNote on async and blocking: @async is allowed in actor code, but async code should not operate directly on the actor state, only through messages. Blocking operations will also work inside onmessage, but in the Classic model it is up to the implementation to provide any or no concurrency of blocked actors, so blocking should generally be avoided if possible.\n\nExamples\n\nusing ActorInterfaces.Classic\n\nmutable struct Counter\n    counter::Int\nend\n\nstruct Increment end\n\n@ctx function (me::Counter)(msg::Increment)\n    me.counter += 1\nend\n\n\n\n\n\n","category":"module"},{"location":"reference/#ActorInterfaces.Classic.Addr","page":"Reference","title":"ActorInterfaces.Classic.Addr","text":"Addr\n\nAddr uniquely identifies an actor, and can be used as the target of messages.\n\n\n\n\n\n","category":"type"},{"location":"reference/#ActorInterfaces.Classic.become","page":"Reference","title":"ActorInterfaces.Classic.become","text":"become(behavior; ctx)\nbecome(behavior, aquintances...; ctx)\n\nReplace the current actor behavior with the given behavior and optionally arguments aquintances to it.\n\nThe new behavior will be effective at the processing of the next message.\n\nThe ctx argument can be automatically injected by @ctx.\n\nSee also spawn.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ActorInterfaces.Classic.self","page":"Reference","title":"ActorInterfaces.Classic.self","text":"self(; ctx) :: Addr\n\nGet the address of the current actor.\n\nThe ctx argument can be automatically injected by @ctx.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ActorInterfaces.Classic.send","page":"Reference","title":"ActorInterfaces.Classic.send","text":"send(recipient::Addr, msg...; ctx)\n\nSend the message msg to a recipient actor address.\n\nIt is possible to send multiple arguments as a single message.\n\nThe ctx argument can be automatically injected by @ctx.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ActorInterfaces.Classic.spawn","page":"Reference","title":"ActorInterfaces.Classic.spawn","text":"spawn(behavior; ctx) :: Addr\nspawn(behavior, aquintances...; ctx) :: Addr\n\nCreate a new actor with the given behavior and optionally arguments aquintances to it.\n\nbehavior can be any callable object (function, closure or functor).\n\nIf aquintances are given, they will be stored and later provided with every incoming message to the behavior (as the first arguments to the call, before the message), simulating state in a functional style.\n\nIf behavior is a functor, it can store its state inside, without externally given aquintances (called the OOP style).\n\nThe returned address can be used to send messages to the newly created actor. The actor itself is not accessible directly.\n\nThe ctx argument can be automatically injected by @ctx.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ActorInterfaces.Classic.@ctx-Tuple{Any}","page":"Reference","title":"ActorInterfaces.Classic.@ctx","text":"@ctx\n\nInject the actor context into onmessage methods automatically.\n\nThe \"actor context\" allows the runtime to identify the current actor efficiently. It is passed to onmessage and must be provided to every actor primitive call. It can either be handled explicitly by the user or implicitly by the @ctx macro.\n\nWhen an onmessage method definition is marked with @ctx, calls to send, spawn, etc. from it need not to handle the ctx argument, it will be injected by the macro.\n\n\n\n\n\n","category":"macro"},{"location":"#ActorInterfaces.jl-1","page":"ActorInterfaces.jl","title":"ActorInterfaces.jl","text":"","category":"section"},{"location":"#","page":"ActorInterfaces.jl","title":"ActorInterfaces.jl","text":"ActorInterfaces.jl is a formalisation of the actor model family in Julia. Its main goal is to allow writing actor programs independently from any specific implementation of the model. Programs written on top of ActorInterfaces.jl will potentially run on several actor systems.","category":"page"},{"location":"#","page":"ActorInterfaces.jl","title":"ActorInterfaces.jl","text":"There is no such thing as The Actor Model, there are interpretations and extensions of it. ActorInterfaces tries to handle this diversity by defining a minimalistic base called the Classic Model, and extensions to it. ","category":"page"},{"location":"#","page":"ActorInterfaces.jl","title":"ActorInterfaces.jl","text":"Current State: The Classic interface settled recently, major semantical changes are unlikely. Extensions will be added continously. If you have an extension idea, please open an issue or a topic on Discourse.","category":"page"},{"location":"#","page":"ActorInterfaces.jl","title":"ActorInterfaces.jl","text":"Known implementations:","category":"page"},{"location":"#","page":"ActorInterfaces.jl","title":"ActorInterfaces.jl","text":"QuickActors.jl, reference implementation.","category":"page"}]
}
